{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport React, { useState, useEffect, useReducer } from \"react\";\nimport axios from \"axios\";\n\nconst dataFetchReducer = (state, action) => {\n  switch (action.type) {\n    case \"FETCH_INIT\":\n      return _objectSpread(_objectSpread({}, state), {}, {\n        isLoading: true,\n        isError: false\n      });\n\n    case \"FETCH_SUCCESS\":\n      return _objectSpread(_objectSpread({}, state), {}, {\n        isLoading: false,\n        hasErrored: false,\n        errorMessage: \"\",\n        data: action.payload\n      });\n\n    case \"FETCH_FAILURE\":\n      return _objectSpread(_objectSpread({}, state), {}, {\n        isLoading: false,\n        hasErrored: true,\n        errorMessage: \"Data Retrieve Failure\"\n      });\n\n    case \"REPLACE_DATA\":\n      // The record passed (state.data) must have the attribute \"id\"\n      const newData = state.data.map(rec => {\n        return rec.id === action.replacerecord.id ? action.replacerecord : rec;\n      });\n      return _objectSpread(_objectSpread({}, state), {}, {\n        isLoading: false,\n        hasErrored: false,\n        errorMessage: \"\",\n        data: newData\n      });\n\n    default:\n      throw new Error();\n  }\n};\n\nconst useAxiosFetch = (initialUrl, initialData) => {\n  const {\n    0: url\n  } = useState(initialUrl);\n  const {\n    0: state,\n    1: dispatch\n  } = useReducer(dataFetchReducer, {\n    isLoading: false,\n    hasErrored: false,\n    errorMessage: \"\",\n    data: initialData\n  });\n  useEffect(() => {\n    let didCancel = false;\n\n    const fetchData = async () => {\n      dispatch({\n        type: \"FETCH_INIT\"\n      });\n\n      try {\n        let result = await axios.get(url);\n\n        if (!didCancel) {\n          dispatch({\n            type: \"FETCH_SUCCESS\",\n            payload: result.data\n          });\n        }\n      } catch (err) {\n        if (!didCancel) {\n          dispatch({\n            type: \"FETCH_FAILURE\"\n          });\n        }\n      }\n    };\n\n    fetchData();\n    return () => {\n      didCancel = true;\n    };\n  }, [url]);\n\n  const updateDataRecord = record => {\n    dispatch({\n      type: \"REPLACE_DATA\",\n      replacerecord: record\n    });\n  };\n\n  return _objectSpread(_objectSpread({}, state), {}, {\n    updateDataRecord\n  });\n};\n\nexport default useAxiosFetch;","map":{"version":3,"sources":["/app/src/useAxiosFetch.js"],"names":["React","useState","useEffect","useReducer","axios","dataFetchReducer","state","action","type","isLoading","isError","hasErrored","errorMessage","data","payload","newData","map","rec","id","replacerecord","Error","useAxiosFetch","initialUrl","initialData","url","dispatch","didCancel","fetchData","result","get","err","updateDataRecord","record"],"mappings":"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","sourcesContent":["import React, { useState, useEffect, useReducer } from \"react\";\nimport axios from \"axios\";\n\nconst dataFetchReducer = (state, action) => {\n  switch (action.type) {\n    case \"FETCH_INIT\":\n      return { ...state, isLoading: true, isError: false };\n    case \"FETCH_SUCCESS\":\n      return {\n        ...state,\n        isLoading: false,\n        hasErrored: false,\n        errorMessage: \"\",\n        data: action.payload\n      };\n    case \"FETCH_FAILURE\":\n      return {\n        ...state,\n        isLoading: false,\n        hasErrored: true,\n        errorMessage: \"Data Retrieve Failure\"\n      };\n    case \"REPLACE_DATA\":\n      // The record passed (state.data) must have the attribute \"id\"\n      const newData = state.data.map(rec => {\n        return rec.id === action.replacerecord.id ? action.replacerecord : rec;\n      });\n      return {\n        ...state,\n        isLoading: false,\n        hasErrored: false,\n        errorMessage: \"\",\n        data: newData\n      };\n    default:\n      throw new Error();\n  }\n};\n\nconst useAxiosFetch = (initialUrl, initialData) => {\n  const [url] = useState(initialUrl);\n\n  const [state, dispatch] = useReducer(dataFetchReducer, {\n    isLoading: false,\n    hasErrored: false,\n    errorMessage: \"\",\n    data: initialData\n  });\n\n  useEffect(() => {\n    let didCancel = false;\n\n    const fetchData = async () => {\n      dispatch({ type: \"FETCH_INIT\" });\n\n      try {\n        let result = await axios.get(url);\n        if (!didCancel) {\n          dispatch({ type: \"FETCH_SUCCESS\", payload: result.data });\n        }\n      } catch (err) {\n        if (!didCancel) {\n          dispatch({ type: \"FETCH_FAILURE\" });\n        }\n      }\n    };\n\n    fetchData();\n\n    return () => {\n      didCancel = true;\n    };\n  }, [url]);\n\n  const updateDataRecord = record => {\n    dispatch({\n      type: \"REPLACE_DATA\",\n      replacerecord: record\n    });\n  };\n\n  return { ...state, updateDataRecord };\n};\n\nexport default useAxiosFetch;\n"]},"metadata":{},"sourceType":"module"}